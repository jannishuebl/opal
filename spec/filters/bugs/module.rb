opal_filter "Module" do
  fails "passed { |a, b = 1|  } creates a method that raises an ArgumentError when passed zero arguments"
  fails "passed { |a, b = 1|  } creates a method that raises an ArgumentError when passed three arguments"
  fails "Module#define_method passed {  } creates a method that raises an ArgumentError when passed one argument"
  fails "Module#define_method calls #method_added after the method is added to the Module"
  fails "Module#define_method passed {  } creates a method that raises an ArgumentError when passed two arguments"
  fails "Module#define_method passed { ||  } creates a method that raises an ArgumentError when passed one argument"
  fails "Module#define_method passed { ||  } creates a method that raises an ArgumentError when passed two arguments"
  fails "Module#define_method passed { |a|  } creates a method that raises an ArgumentError when passed zero arguments"
  fails "Module#define_method passed { |a|  } creates a method that raises an ArgumentError when passed zero arguments and a block"
  fails "Module#define_method passed { |a|  } creates a method that raises an ArgumentError when passed two arguments"
  fails "Module#define_method passed { |a, *b|  } creates a method that raises an ArgumentError when passed zero arguments"
  fails "Module#define_method passed { |a, b|  } creates a method that raises an ArgumentError when passed zero arguments"
  fails "Module#define_method passed { |a, b|  } creates a method that raises an ArgumentError when passed one argument"
  fails "Module#define_method passed { |a, b|  } creates a method that raises an ArgumentError when passed one argument and a block"
  fails "Module#define_method passed { |a, b|  } creates a method that raises an ArgumentError when passed three arguments"
  fails "Module#define_method passed { |a, b, *c|  } creates a method that raises an ArgumentError when passed zero arguments"
  fails "Module#define_method passed { |a, b, *c|  } creates a method that raises an ArgumentError when passed one argument"
  fails "Module#define_method passed { |a, b, *c|  } creates a method that raises an ArgumentError when passed one argument and a block"
  fails "Module#define_method does not change the arity check style of the original proc"
  fails "A class definition has no class variables"
  fails "A class definition allows the declaration of class variables in the body"
  fails "A class definition allows the declaration of class variables in a class method"
  fails "A class definition allows the declaration of class variables in an instance method"

  fails "Module#method_defined? converts the given name to a string using to_str"
  fails "Module#method_defined? raises a TypeError when the given object is not a string/symbol/fixnum"
  fails "Module#method_defined? returns true if a public or private method with the given name is defined in self, self's ancestors or one of self's included modules"

  fails "Module#const_defined? should not search parent scopes of classes and modules if inherit is false"
  fails "Module#const_get should not search parent scopes of classes and modules if inherit is false"
  fails "Module#const_get raises a NameError with the not found constant symbol"
  fails "Module#const_get calls #to_str to convert the given name to a String"
  fails "Module#const_get raises a TypeError if conversion to a String by calling #to_str fails"
  fails "Module#const_get does not search the singleton class of a Class or Module"
  fails "Module#const_get raises a NameError if the constant is defined in the receiver's supperclass and the inherit flag is false"
  fails "Module#const_get accepts a toplevel scope qualifier"
  fails "Module#const_get raises a NameError if a Symbol is a scoped constant name"
  fails "Module#const_get with dynamically assigned constants searches a module included in the immediate class before the superclass"
  fails "Module#const_get with dynamically assigned constants searches a module included in the superclass"
  fails "Module#const_get with dynamically assigned constants searches the superclass chain"

  fails "Module#class_variable_set sets the value of a class variable with the given name defined in an included module"
  fails "Module#class_variable_get returns the value of a class variable with the given name defined in an included module"

  fails "Module#module_function as a toggle (no arguments) in a Module body functions normally if both toggle and definitions inside a eval"

  fails "Module#module_function is a private method"
  fails "Module#module_function on Class raises a TypeError if calling after rebinded to Class"
  fails "Module#module_function with specific method names makes the instance methods private"
  fails "Module#module_function with specific method names tries to convert the given names to strings using to_str"
  fails "Module#module_function with specific method names raises a TypeError when the given names can't be converted to string using to_str"
  fails "Module#module_function with specific method names can make accessible private methods"
  fails "Module#module_function as a toggle (no arguments) in a Module body does not affect module_evaled method definitions also if outside the eval itself"
  fails "Module#module_function as a toggle (no arguments) in a Module body has no effect if inside a module_eval if the definitions are outside of it"

  fails "Module#include adds all ancestor modules when a previously included module is included again"
  fails "Module#include raises a TypeError when the argument is not a Module"
  fails "Module#include doesn't include module if it is included in a super class"
  fails "Module#include recursively includes new mixins"
  fails "Module#include preserves ancestor order"
  fails "Module#include detects cyclic includes"
  fails "Module#include ignores modules it has already included via module mutual inclusion"
  fails "Module#include? returns true if the given module is included by self or one of it's ancestors"
  fails "Module#include? raises a TypeError when no module was given"

  fails "Module#module_function as a toggle (no arguments) in a Module body doesn't affect definitions when inside an eval even if the definitions are outside of it"
  fails "Module#define_method raises a TypeError when an UnboundMethod from a child class is defined on a parent class"
  fails "Module#define_method raises a TypeError when an UnboundMethod from one class is defined on an unrelated class"

  fails "Module#alias_method preserves the arguments information of the original methods"
  fails "Module#alias_method retains method visibility"
  fails "Module#alias_method fails if origin method not found"
  fails "Module#alias_method raises RuntimeError if frozen"
  fails "Module#alias_method raises a TypeError when the given name can't be converted using to_str"
  fails "Module#alias_method is a private method"
  fails "Module#alias_method accesses a method defined on Object from Kernel"
  fails "Module#alias_method can call a method with super aliased twice"
  fails "Module#alias_method aliasing special methods keeps initialize private when aliasing"
  fails "Module#alias_method aliasing special methods keeps initialize_copy private when aliasing"
  fails "Module#alias_method aliasing special methods keeps initialize_clone private when aliasing"
  fails "Module#alias_method aliasing special methods keeps initialize_dup private when aliasing"
  fails "Module#alias_method aliasing special methods keeps respond_to_missing? private when aliasing"
  fails "Module.allocate returns a fully-formed instance of Module"
  fails "Module#ancestors returns a list of modules included in self (including self)"
  fails "Module#ancestors returns only modules and classes"
  fails "Module#ancestors when called on a singleton class includes the singleton classes of ancestors"
  fails "Module#append_features is a private method"
  fails "Module#append_features raises an ArgumentError on a cyclic include"
  fails "Module#append_features copies own tainted status to the given module"
  fails "Module#append_features copies own untrusted status to the given module"
  fails "Module#append_features on Class raises a TypeError if calling after rebinded to Class"
  fails "Module#append_features when other is frozen raises a RuntimeError before appending self"
  fails "Module#attr_accessor allows creating an attr_accessor on an immediate class"
  fails "Module#attr_accessor converts non string/symbol/fixnum names to strings using to_str"
  fails "Module#attr_accessor raises a TypeError when the given names can't be converted to strings using to_str"
  fails "Module#attr_accessor applies current visibility to methods created"
  fails "Module#attr_accessor is a private method"
  fails "Module#attr_reader allows for adding an attr_reader to an immediate"
  fails "Module#attr_reader converts non string/symbol/fixnum names to strings using to_str"
  fails "Module#attr_reader raises a TypeError when the given names can't be converted to strings using to_str"
  fails "Module#attr_reader applies current visibility to methods created"
  fails "Module#attr_reader is a private method"
  fails "Module#attr creates a getter for the given attribute name"
  fails "Module#attr applies current visibility to methods created"
  fails "Module#attr creates a getter but no setter for all given attribute names"
  fails "Module#attr applies current visibility to methods created"
  fails "Module#attr converts non string/symbol/fixnum names to strings using to_str"
  fails "Module#attr raises a TypeError when the given names can't be converted to strings using to_str"
  fails "Module#attr is a private method"
  fails "Module#attr_writer allows for adding an attr_writer to an immediate"
  fails "Module#attr_writer converts non string/symbol/fixnum names to strings using to_str"
  fails "Module#attr_writer raises a TypeError when the given names can't be converted to strings using to_str"
  fails "Module#attr_writer applies current visibility to methods created"
  fails "Module#attr_writer is a private method"
  fails "Module#=== returns true when the given Object's class includes self or when the given Object is extended by self"
  fails "Module#class_eval evaluates a given string in the context of self"
  fails "Module#class_eval defines constants in the receiver's scope"
  fails "Module#class_eval uses the optional filename and lineno parameters for error messages"
  fails "Module#class_eval converts a non-string filename to a string using to_str"
  fails "Module#class_eval raises a TypeError when the given filename can't be converted to string using to_str"
  fails "Module#class_eval converts non string eval-string to string using to_str"
  fails "Module#class_eval raises a TypeError when the given eval-string can't be converted to string using to_str"
  fails "Module#class_eval adds methods respecting the lexical constant scope"
  fails "Module#class_exec defines method in the receiver's scope"
  fails "Module#class_exec raises a LocalJumpError when no block is given"
  fails "Module#class_exec passes arguments to the block"
  fails "Module#class_variable_defined? returns true if a class variable with the given name is defined in self"
  fails "Module#class_variable_defined? returns true if a class variable with the given name is defined in the metaclass"
  fails "Module#class_variable_defined? returns true if the class variable is defined in a metaclass"
  fails "Module#class_variable_defined? returns false if the class variable is not defined in a metaclass"
  fails "Module#class_variable_defined? returns true if a class variables with the given name is defined in an included module"
  fails "Module#class_variable_defined? returns false if a class variables with the given name is defined in an extended module"
  fails "Module#class_variable_defined? converts a non string/symbol/fixnum name to string using to_str"
  fails "Module#class_variable_defined? raises a TypeError when the given names can't be converted to strings using to_str"
  fails "Module#class_variables returns an Array with the names of class variables of self"
  fails "Module#class_variables returns an Array of Symbols of class variable names defined in a metaclass"
  fails "Module#class_variables returns an Array with names of class variables defined in metaclasses"
  fails "Module#class_variables does not return class variables defined in extended modules"
  fails "Module#<=> returns -1 if self is a subclass of or includes the given module"
  fails "Module#<=> returns +1 if self is a superclas of or included by the given module"
  fails "Module#const_missing raises NameError and does not include toplevel Object"
  fails "Module.constants returns an array of Symbol names"
  fails "Module.constants returns Module's constants when given a parameter"
  fails "Module#constants returns an array of Symbol names of all constants defined in the module and all included modules"
  fails "Module#constants returns all constants including inherited when passed true"
  fails "Module#constants returns all constants including inherited when passed some object"
  fails "Module#constants includes names of constants defined after a module is included"
  fails "Module#constants doesn't returns inherited constants when passed false"
  fails "Module#constants doesn't returns inherited constants when passed nil"
  fails "Module#constants returns only public constants"
  fails "Module#extend_object is a private method"
  fails "Module#extend_object extends the given object with its constants and methods by default"
  fails "Module#extend_object is called even when private"
  fails "Module#extend_object is called when #extend is called on an object"
  fails "Module#extend_object does not copy own tainted status to the given object"
  fails "Module#extend_object does not copy own untrusted status to the given object"
  fails "Module#extend_object on Class raises a TypeError if calling after rebinded to Class"
  fails "Module#extend_object when given a frozen object raises a RuntimeError before extending the object"
  fails "Module#extended is private in its default implementation"
  fails "Module#> returns false if self is a subclass of or includes the given module"
  fails "Module#> returns true if self is a superclass of or included by the given module"
  fails "Module#> returns false if self is the same as the given module"
  fails "Module#> returns nil if self is not related to the given module"
  fails "Module#> raises a TypeError if the argument is not a class/module"
  fails "Module#>= returns true if self is a superclass of, the same as or included by given module"
  fails "Module#>= returns nil if self is not related to the given module"
  fails "Module#>= returns false if self is a subclass of or includes the given module"
  fails "Module#>= raises a TypeError if the argument is not a class/module"
  fails "Module#included_modules returns a list of modules included in self"
  fails "Module#included is private in its default implementation"
  fails "Module#initialize is called on subclasses"
  fails "Module#instance_method gives UnboundMethod method name, Module defined in and Module extracted from"
  fails "Module#instance_method raises a TypeError if not passed a symbol"
  fails "Module#instance_method raises a TypeError if the given name is not a string/symbol"
  fails "Module#instance_method raises a NameError if the method has been undefined"
  fails "Module#instance_method sets the NameError#name attribute to the name of the missing method"
  fails "Module#< returns true if self is a subclass of or includes the given module"
  fails "Module#< returns false if self is the same as the given module"
  fails "Module#< returns nil if self is not related to the given module"
  fails "Module#< raises a TypeError if the argument is not a class/module"
  fails "Module#<= returns true if self is a subclass of, the same as or includes the given module"
  fails "Module#<= returns nil if self is not related to the given module"
  fails "Module#<= returns false if self is a superclass of or is included by the given module"
  fails "Module#<= raises a TypeError if the argument is not a class/module"
  fails "Module#method_added is a private instance method"
  fails "Module#method_added returns nil in the default implementation"
  fails "Module#method_added is called when a new method is defined in self"
  fails "Module#method_removed is a private instance method"
  fails "Module#method_removed returns nil in the default implementation"
  fails "Module#method_removed is called when a method is removed from self"
  fails "Module#method_undefined is a private instance method"
  fails "Module#method_undefined returns nil in the default implementation"
  fails "Module#method_undefined is called when a method is undefined from self"
  fails "Module#module_eval evaluates a given string in the context of self"
  fails "Module#module_eval defines constants in the receiver's scope"
  fails "Module#module_eval uses the optional filename and lineno parameters for error messages"
  fails "Module#module_eval converts a non-string filename to a string using to_str"
  fails "Module#module_eval raises a TypeError when the given filename can't be converted to string using to_str"
  fails "Module#module_eval converts non string eval-string to string using to_str"
  fails "Module#module_eval raises a TypeError when the given eval-string can't be converted to string using to_str"
  fails "Module#module_eval adds methods respecting the lexical constant scope"
  fails "Module#module_exec defines method in the receiver's scope"
  fails "Module#module_exec raises a LocalJumpError when no block is given"
  fails "Module#module_exec passes arguments to the block"
  fails "Module::Nesting returns the list of Modules nested at the point of call"
  fails "Module::Nesting returns the nesting for module/class declaring the called method"
  fails "Module.new creates a new Module and passes it to the provided block"
  fails "Module#prepend_features is a private method"
  fails "Module#prepend_features gets called when self is included in another module/class"
  fails "Module#prepend_features raises an ArgumentError on a cyclic prepend"
  fails "Module#prepend_features copies own tainted status to the given module"
  fails "Module#prepend_features copies own untrusted status to the given module"
  fails "Module#prepend_features on Class raises a TypeError if calling after rebinded to Class"
  fails "Module#prepend is a public method"
  fails "Module#prepend calls #prepend_features(self) in reversed order on each module"
  fails "Module#prepend raises a TypeError when the argument is not a Module"
  fails "Module#prepend does not import constants"
  fails "Module#prepend imports instance methods"
  fails "Module#prepend does not import methods to modules and classes"
  fails "Module#prepend allows wrapping methods"
  fails "Module#prepend also prepends included modules"
  fails "Module#prepend prepends multiple modules in the right order"
  fails "Module#prepend includes prepended modules in ancestors"
  fails "Module#prepend reports the prepended module as the method owner"
  fails "Module#prepend reports the prepended module as the unbound method owner"
  fails "Module#prepend causes the prepended module's method to be aliased by alias_method"
  fails "Module#prepend sees an instance of a prepended class as kind of the prepended module"
  fails "Module#prepend keeps the module in the chain when dupping the class"
  fails "Module#prepend keeps the module in the chain when dupping an intermediate module"
  fails "Module#prepend depends on prepend_features to add the module"
  fails "Module#prepend inserts a later prepended module into the chain"
  fails "Module#prepend works with subclasses"
  fails "Module#prepend throws a NoMethodError when there is no more superclass"
  fails "Module#prepend calls prepended after prepend_features"
  fails "Module#prepend detects cyclic prepends"
  fails "Module#prepend accepts no-arguments"
  fails "Module#prepend returns the class it's included into"
  fails "Module#prepend clears any caches"
  fails "Module#prepend supports super when the module is prepended into a singleton class"
  fails "Module#prepended is a private method"
  fails "Module#private_class_method makes an existing class method private"
  fails "Module#private_class_method makes an existing class method private up the inheritance tree"
  fails "Module#private_class_method accepts more than one method at a time"
  fails "Module#private_class_method raises a NameError if class method doesn't exist"
  fails "Module#private_class_method makes a class method private"
  fails "Module#private_class_method raises a NameError when the given name is not a method"
  fails "Module#private_class_method raises a NameError when the given name is an instance method"
  fails "Module#private_constant can only be passed constant names defined in the target (self) module"
  fails "Module#private_constant accepts multiple names"
  fails "Module#private_instance_methods returns a list of private methods in module and its ancestors"
  fails "Module#private_instance_methods when passed false as a parameter, should return only methods defined in that module"
  fails "Module#private_instance_methods when not passed an argument returns a unique list for a class including a module"
  fails "Module#private_instance_methods when not passed an argument returns a unique list for a subclass"
  fails "Module#private_instance_methods when passed true returns a unique list for a class including a module"
  fails "Module#private_instance_methods when passed true returns a unique list for a subclass"
  fails "Module#private_method_defined? returns true if the named private method is defined by module or its ancestors"
  fails "Module#private_method_defined? accepts symbols for the method name"
  fails "Module#private_method_defined? raises a TypeError if passed a Fixnum"
  fails "Module#private_method_defined? raises a TypeError if passed nil"
  fails "Module#private_method_defined? raises a TypeError if passed false"
  fails "Module#private_method_defined? raises a TypeError if passed an object that does not defined #to_str"
  fails "Module#private_method_defined? raises a TypeError if passed an object that defines #to_sym"
  fails "Module#private_method_defined? calls #to_str to convert an Object"
  fails "Module#private is a private method"
  fails "Module#private makes the target method uncallable from other types"
  fails "Module#private makes a public Object instance method private in a new module"
  fails "Module#private makes a public Object instance method private in Kernel"
  fails "Module#private returns self"
  fails "Module#private raises a NameError when given an undefined name"
  fails "Module#private without arguments sets visibility to following method definitions"
  fails "Module#private without arguments stops setting visibility if the body encounters other visibility setters without arguments"
  fails "Module#private without arguments continues setting visibility if the body encounters other visibility setters with arguments"
  fails "Module#private without arguments does not affect module_evaled method definitions when itself is outside the eval"
  fails "Module#private without arguments affects normally if itself and method definitions are inside a module_eval"
  fails "Module#private without arguments does not affect method definitions when itself is inside an eval and method definitions are outside"
  fails "Module#private without arguments affects evaled method definitions when itself is outside the eval"
  fails "Module#private without arguments affects normally if itself and following method definitions are inside a eval"
  fails "Module#protected_instance_methods returns a list of protected methods in module and its ancestors"
  fails "Module#protected_instance_methods when passed false as a parameter, should return only methods defined in that module"
  fails "Module#protected_instance_methods default list should be the same as passing true as an argument"
  fails "Module#protected_instance_methods when not passed an argument returns a unique list for a class including a module"
  fails "Module#protected_instance_methods when not passed an argument returns a unique list for a subclass"
  fails "Module#protected_instance_methods when passed true returns a unique list for a class including a module"
  fails "Module#protected_instance_methods when passed true returns a unique list for a subclass"
  fails "Module#protected_method_defined? returns true if the named protected method is defined by module or its ancestors"
  fails "Module#protected_method_defined? accepts symbols for the method name"
  fails "Module#protected_method_defined? raises a TypeError if passed a Fixnum"
  fails "Module#protected_method_defined? raises a TypeError if passed nil"
  fails "Module#protected_method_defined? raises a TypeError if passed false"
  fails "Module#protected_method_defined? raises a TypeError if passed an object that does not defined #to_str"
  fails "Module#protected_method_defined? raises a TypeError if passed an object that defines #to_sym"
  fails "Module#protected_method_defined? calls #to_str to convert an Object"
  fails "Module#protected is a private method"
  fails "Module#protected makes an existing class method protected"
  fails "Module#protected makes a public Object instance method protected in a new module"
  fails "Module#protected makes a public Object instance method protected in Kernel"
  fails "Module#protected returns self"
  fails "Module#protected raises a NameError when given an undefined name"
  fails "Module#protected without arguments sets visibility to following method definitions"
  fails "Module#protected without arguments stops setting visibility if the body encounters other visibility setters without arguments"
  fails "Module#protected without arguments continues setting visibility if the body encounters other visibility setters with arguments"
  fails "Module#protected without arguments does not affect module_evaled method definitions when itself is outside the eval"
  fails "Module#protected without arguments affects normally if itself and method definitions are inside a module_eval"
  fails "Module#protected without arguments does not affect method definitions when itself is inside an eval and method definitions are outside"
  fails "Module#protected without arguments affects evaled method definitions when itself is outside the eval"
  fails "Module#protected without arguments affects normally if itself and following method definitions are inside a eval"
  fails "Module#public_class_method makes an existing class method public"
  fails "Module#public_class_method makes an existing class method public up the inheritance tree"
  fails "Module#public_class_method accepts more than one method at a time"
  fails "Module#public_class_method raises a NameError if class method doesn't exist"
  fails "Module#public_class_method raises a NameError when the given name is not a method"
  fails "Module#public_class_method raises a NameError when the given name is an instance method"
  fails "Module#public_constant accepts multiple names"
  fails "Module#public_instance_method is a public method"
  fails "Module#public_instance_method requires an argument"
  fails "Module#public_instance_method raises a TypeError when given a name is not Symbol or String"
  fails "Module#public_instance_method sets the NameError#name attribute to the name of the missing method"
  fails "Module#public_instance_method when given a public method name returns an UnboundMethod corresponding to the defined Module"
  fails "Module#public_instance_method when given a public method name accepts if the name is a Symbol or String"
  fails "Module#public_instance_methods when passed false as a parameter, should return only methods defined in that module"
  fails "Module#public_method_defined? returns false if method is not a public method"
  fails "Module#public_method_defined? raises a TypeError if passed a Fixnum"
  fails "Module#public_method_defined? raises a TypeError if passed nil"
  fails "Module#public_method_defined? raises a TypeError if passed false"
  fails "Module#public_method_defined? raises a TypeError if passed an object that does not defined #to_str"
  fails "Module#public_method_defined? raises a TypeError if passed an object that defines #to_sym"
  fails "Module#public_method_defined? calls #to_str to convert an Object"
  fails "Module#public is a private method"
  fails "Module#public makes a private Object instance method public in a new module"
  fails "Module#public makes a private Object instance method public in Kernel"
  fails "Module#public returns self"
  fails "Module#public raises a NameError when given an undefined name"
  fails "Module#public without arguments stops setting visibility if the body encounters other visibility setters without arguments"
  fails "Module#public without arguments does not affect module_evaled method definitions when itself is outside the eval"
  fails "Module#public without arguments does not affect method definitions when itself is inside an eval and method definitions are outside"
  fails "Module#public without arguments affects evaled method definitions when itself is outside the eval"
  fails "Module#public without arguments affects normally if itself and following method definitions are inside a eval"
  fails "Module#remove_class_variable removes class variable"
  fails "Module#remove_class_variable returns the value of removing class variable"
  fails "Module#remove_class_variable removes a class variable defined in a metaclass"
  fails "Module#remove_class_variable raises a NameError when passed a symbol with one leading @"
  fails "Module#remove_class_variable raises a NameError when passed a symbol with no leading @"
  fails "Module#remove_class_variable raises a NameError when an uninitialized class variable is given"
  fails "Module#remove_const raises a NameError and does not call #const_missing if the constant is not defined"
  fails "Module#remove_const raises a NameError and does not call #const_missing if the constant is not defined directly in the module"
  fails "Module#remove_const raises a NameError if the name does not start with a capital letter"
  fails "Module#remove_const raises a NameError if the name starts with a non-alphabetic character"
  fails "Module#remove_const raises a NameError if the name contains non-alphabetic characters except '_'"
  fails "Module#remove_const calls #to_str to convert the given name to a String"
  fails "Module#remove_const raises a TypeError if conversion to a String by calling #to_str fails"
  fails "Module#remove_const is a private method"
  fails "Module#remove_method is a private method"
  fails "Module#remove_method accepts multiple arguments"
  fails "Module#remove_method does not remove any instance methods when argument not given"
  fails "Module#remove_method raises a NameError when attempting to remove method further up the inheritance tree"
  fails "Module#remove_method raises a NameError when attempting to remove a missing method"
  fails "Module#remove_method on frozen instance raises a RuntimeError when passed a name"
  fails "Module#remove_method on frozen instance raises a RuntimeError when passed a missing name"
  fails "Module#remove_method on frozen instance raises a TypeError when passed a not name"
  fails "Module#remove_method on frozen instance does not raise exceptions when no arguments given"
  fails "Module#undef_method is a private method"
  fails "Module#undef_method requires multiple arguments"
  fails "Module#undef_method does not undef any instance methods when argument not given"
  fails "Module#undef_method raises a NameError when passed a missing name"
  fails "Module#undef_method on frozen instance raises a RuntimeError when passed a name"
  fails "Module#undef_method on frozen instance raises a RuntimeError when passed a missing name"
  fails "Module#undef_method on frozen instance raises a TypeError when passed a not name"
  fails "Module#undef_method on frozen instance does not raise exceptions when no arguments given"
  fails "Module#undef_method with symbol removes a method defined in a super class"
  fails "Module#undef_method with string removes a method defined in a super class"
end
